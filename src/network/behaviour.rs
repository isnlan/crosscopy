//! libp2p network behaviour implementation for CrossCopy

use libp2p::{
    mdns,
    swarm::NetworkBehaviour,
    PeerId, Multiaddr,
};
use serde::{Deserialize, Serialize};

/// Simple clipboard content message
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClipboardMessage {
    pub content: Vec<u8>,
    pub content_type: String,
    pub timestamp: u64,
    pub device_id: String,
}

/// Network events generated by CrossCopy behaviour
#[derive(Debug)]
pub enum CrossCopyEvent {
    PeerDiscovered {
        peer_id: PeerId,
        addresses: Vec<Multiaddr>,
    },
    PeerExpired {
        peer_id: PeerId,
    },
}

/// Main network behaviour for CrossCopy (simplified with mDNS only)
#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "CrossCopyEvent")]
pub struct CrossCopyBehaviour {
    pub mdns: mdns::tokio::Behaviour,
}

impl CrossCopyBehaviour {
    /// Create a new CrossCopy behaviour
    pub fn new(local_peer_id: PeerId) -> std::result::Result<Self, Box<dyn std::error::Error>> {
        // Create mDNS behaviour
        let mdns = mdns::tokio::Behaviour::new(
            mdns::Config::default(),
            local_peer_id,
        )?;

        Ok(Self { mdns })
    }
}

impl From<mdns::Event> for CrossCopyEvent {
    fn from(event: mdns::Event) -> Self {
        match event {
            mdns::Event::Discovered(list) => {
                // Emit events for all discovered peers
                if let Some((peer_id, addresses)) = list.into_iter().next() {
                    CrossCopyEvent::PeerDiscovered {
                        peer_id,
                        addresses: vec![addresses], // addresses is already a Multiaddr
                    }
                } else {
                    // Fallback - shouldn't happen
                    CrossCopyEvent::PeerDiscovered {
                        peer_id: PeerId::random(),
                        addresses: vec![],
                    }
                }
            }
            mdns::Event::Expired(list) => {
                if let Some((peer_id, _)) = list.into_iter().next() {
                    CrossCopyEvent::PeerExpired { peer_id }
                } else {
                    // Fallback - shouldn't happen
                    CrossCopyEvent::PeerExpired {
                        peer_id: PeerId::random(),
                    }
                }
            }
        }
    }
}
